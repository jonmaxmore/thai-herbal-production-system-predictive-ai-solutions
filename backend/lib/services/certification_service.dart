import 'package:thai_herbal_backend/models/certification.dart';
import 'package:thai_herbal_backend/core/database/postgres_repository.dart';
import 'package:thai_herbal_backend/core/ai/ai_service.dart';
import 'package:thai_herbal_backend/services/notification_service.dart';
import 'package:thai_herbal_backend/core/utils/qr_generator.dart';

class CertificationService {
  final PostgresRepository _repository;
  final AIService _aiService;
  final NotificationService _notificationService;

  CertificationService(this._repository, this._aiService, this._notificationService);

  Future<CertificationApplication> submitApplication(
    int farmerId,
    List<String> documents,
    List<String> images,
  ) async {
    // Initial AI analysis
    final aiResult = await _aiService.analyzeInitialSubmission(images);
    
    final application = CertificationApplication(
      id: 0, // Will be generated by DB
      farmerId: farmerId,
      createdAt: DateTime.now(),
      status: aiResult.isApproved
          ? CertificationStatus.initialAiApproved
          : CertificationStatus.initialAiRejected,
      documents: documents,
      images: images,
      rejectionReason: aiResult.rejectionReason,
    );

    // Save to database
    final result = await _repository.query('''
      INSERT INTO certification_applications (
        farmer_id, status, documents, images, rejection_reason
      ) VALUES (
        @farmerId, @status, @documents, @images, @rejectionReason
      ) RETURNING id
    ''', substitutionValues: {
      'farmerId': application.farmerId,
      'status': application.status.name,
      'documents': json.encode(application.documents),
      'images': json.encode(application.images),
      'rejectionReason': application.rejectionReason,
    });

    final id = result.first[0] as int;
    application.id = id;

    // Send notification
    if (application.status == CertificationStatus.initialAiRejected) {
      await _notificationService.sendRejectionNotification(
        farmerId,
        'Application rejected: ${aiResult.rejectionReason}',
        application.id,
      );
    } else {
      await _notificationService.notifyPredictiveTeam(application.id);
    }

    return application;
  }

  Future<void> scheduleRemoteAssessment(
    int applicationId,
    int teamMemberId,
    DateTime assessmentDate,
    String meetingLink,
  ) async {
    await _repository.query('''
      UPDATE certification_applications
      SET 
        status = @status,
        predictive_team_member_id = @teamMemberId,
        remote_assessment_date = @assessmentDate,
        remote_meeting_link = @meetingLink
      WHERE id = @applicationId
    ''', substitutionValues: {
      'status': CertificationStatus.remoteAssessmentScheduled.name,
      'teamMemberId': teamMemberId,
      'assessmentDate': assessmentDate.toIso8601String(),
      'meetingLink': meetingLink,
      'applicationId': applicationId,
    });

    // Notify farmer
    final application = await _getApplication(applicationId);
    await _notificationService.sendMeetingScheduledNotification(
      application.farmerId,
      assessmentDate,
      meetingLink,
    );
  }

  Future<CertificationApplication> completeRemoteAssessment(
    int applicationId,
    List<String> additionalImages,
  ) async {
    // Analyze additional images
    final aiResult = await _aiService.analyzeAdditionalImages(additionalImages);
    
    final newStatus = aiResult.isApproved
        ? CertificationStatus.remoteAiApproved
        : CertificationStatus.remoteAiRejected;

    await _repository.query('''
      UPDATE certification_applications
      SET 
        status = @status,
        additional_images = @additionalImages,
        rejection_reason = @rejectionReason
      WHERE id = @applicationId
    ''', substitutionValues: {
      'status': newStatus.name,
      'additionalImages': json.encode(additionalImages),
      'rejectionReason': aiResult.rejectionReason,
      'applicationId': applicationId,
    });

    final application = await _getApplication(applicationId);
    
    if (newStatus == CertificationStatus.remoteAiRejected) {
      await _notificationService.sendRejectionNotification(
        application.farmerId,
        'Remote assessment rejected: ${aiResult.rejectionReason}',
        application.id,
      );
    } else {
      await _notificationService.notifyDpmOfficer(application.id);
    }

    return application;
  }

  Future<void> scheduleFieldInspection(
    int applicationId,
    int officerId,
    DateTime inspectionDate,
  ) async {
    await _repository.query('''
      UPDATE certification_applications
      SET 
        status = @status,
        dpm_officer_id = @officerId,
        field_inspection_date = @inspectionDate
      WHERE id = @applicationId
    ''', substitutionValues: {
      'status': CertificationStatus.fieldInspectionScheduled.name,
      'officerId': officerId,
      'inspectionDate': inspectionDate.toIso8601String(),
      'applicationId': applicationId,
    });

    // Notify farmer
    final application = await _getApplication(applicationId);
    await _notificationService.sendInspectionScheduledNotification(
      application.farmerId,
      inspectionDate,
    );
  }

  Future<CertificationApplication> completeFieldInspection(
    int applicationId,
    bool isApproved,
    String? notes,
  ) async {
    final newStatus = isApproved
        ? CertificationStatus.fieldInspectionApproved
        : CertificationStatus.fieldInspectionRejected;

    await _repository.query('''
      UPDATE certification_applications
      SET 
        status = @status,
        rejection_reason = @rejectionReason
      WHERE id = @applicationId
    ''', substitutionValues: {
      'status': newStatus.name,
      'rejectionReason': isApproved ? null : notes,
      'applicationId': applicationId,
    });

    final application = await _getApplication(applicationId);
    
    if (!isApproved) {
      await _notificationService.sendRejectionNotification(
        application.farmerId,
        'Field inspection failed: $notes',
        application.id,
      );
    } else {
      await _repository.query('''
        UPDATE certification_applications
        SET status = @status
        WHERE id = @applicationId
      ''', substitutionValues: {
        'status': CertificationStatus.labSampleRequested.name,
        'applicationId': applicationId,
      });
      
      await _notificationService.sendLabSampleRequest(
        application.farmerId,
        application.id,
      );
    }

    return application.copyWith(status: newStatus);
  }

  Future<CertificationApplication> issueCertificate(
    int applicationId,
    int officerId,
  ) async {
    final application = await _getApplication(applicationId);
    
    // Generate certificate and QR code
    final certificateUrl = await _generateCertificate(application);
    final qrCode = await QRGenerator.generateGACPQrCode(application.id);
    
    await _repository.query('''
      UPDATE certification_applications
      SET 
        status = @status,
        certificate_url = @certificateUrl,
        qr_code = @qrCode
      WHERE id = @applicationId
    ''', substitutionValues: {
      'status': CertificationStatus.certificateIssued.name,
      'certificateUrl': certificateUrl,
      'qrCode': qrCode,
      'applicationId': applicationId,
    });

    // Notify farmer and enable tracking
    await _notificationService.sendCertificateIssued(
      application.farmerId,
      application.id,
      certificateUrl,
      qrCode,
    );
    
    await _enableTracking(application.id);

    return application.copyWith(
      status: CertificationStatus.certificateIssued,
      certificateUrl: certificateUrl,
      qrCode: qrCode,
    );
  }

  Future<CertificationApplication> _getApplication(int id) async {
    final result = await _repository.query(
      'SELECT * FROM certification_applications WHERE id = @id',
      substitutionValues: {'id': id},
    );
    return CertificationApplication.fromMap(result.first);
  }

  Future<String> _generateCertificate(CertificationApplication application) {
    // Implementation for generating PDF certificate
    return Future.value('https://certificates.thaiherb.org/${application.id}');
  }

  Future<void> _enableTracking(int applicationId) {
    // Implementation to enable QR tracking
    return Future.value();
  }
}
